<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>New Blainslie Feeding Plan</title>
<style>
body { font-family: Arial, sans-serif; margin: 10px; background: #f4f4f4; }
h1 { text-align: center; color: #2a6ebb; font-size: 1.5em; }
#loading { text-align: center; margin: 20px 0; display: none; }
.spinner {
  border: 6px solid #f3f3f3;
  border-top: 6px solid #2a6ebb;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  display: inline-block;
}
@keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
#totalHeadcount { font-size: 16px; margin-bottom: 15px; text-align: center; }
table { border-collapse: collapse; width: 100%; margin-bottom: 20px; display: block; overflow-x: auto; }
th, td { border: 1px solid #444; padding: 8px; text-align: center; min-width: 100px; }
th { background: #2a6ebb; color: white; }
tr:nth-child(even) { background: #f9f9f9; }
input[type="number"] { width: 80px; padding: 5px; text-align: center; border-radius: 4px; border: 1px solid #ccc; }
input[type="number"]:focus { border-color: #2a6ebb; outline: none; background-color: #fff; }
button { margin-top: 15px; padding: 10px; font-size: 16px; border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.3s; }
#generateBtn { background-color: #2a6ebb; color: white; }
#printBtn { background-color: #4CAF50; color: white; }
#pdfBtn { background-color: #f39c12; color: white; }
button:hover { opacity: 0.85; }
#planOutput { margin-top: 20px; background: #fff; padding: 15px; border: 1px solid #ccc; }
@media (max-width: 500px) { button { width: 100%; margin-top: 10px; } }
@media print {
  * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
  body { background: white !important; }
  table th { background-color: #2a6ebb !important; color: white !important; }
  tr:nth-child(even) { background-color: #f9f9f9 !important; }
  #inputs, #loading, #generateBtn, #printBtn, #pdfBtn { display: none !important; }
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
</head>
<body>

<h1>New Blainslie Feeding Plan</h1>
<div id="loading"><div class="spinner"></div> Loading sheds...</div>
<div id="totalHeadcount">Total Headcount: 0</div>
<div id="inputs"></div>
<button id="generateBtn" onclick="generatePlan()">Generate Plan</button>

<div id="planOutput" style="display:none;">
  <button id="printBtn" onclick="printPlan()">Print</button>
  <button id="pdfBtn" onclick="downloadPDF()">Download PDF</button>
</div>

<script>
const MAX_BATCH = 2400;
const RATIONS_URL = "https://script.google.com/macros/s/AKfycbz7xmhtWaSwMcKVqZuuSo1eIAGOTKjThMYuDxyzKi3CNZ-uK8qAd_4ojJkVk8o0iwk/exec";
const YESTERDAY_URL = "https://script.google.com/macros/s/AKfycbydhGdSJ52UomMLIP1GtxyVQe2dflny8PUIC5lfv0vIiqDis_AorTZr_MsbYWaPfCCI/exec";
const SHEDS_URL = "https://script.google.com/macros/s/AKfycbwgA3g-Ps70NR3oBcgv11PU9wPwWg2Q5J_QHVF-aZ_Ix6G6rvOkGoYtYh1gZsL0Ed1K/exec";

let RATIONS = [], SHEDS = [], PLAN = [], TOTAL_HEADCOUNT = 0;

function showLoading(show) { document.getElementById("loading").style.display = show ? "block" : "none"; }

async function fetchRations() {
  try { RATIONS = await (await fetch(RATIONS_URL + "?cacheBust=" + Date.now())).json(); }
  catch (e) { console.error("Error fetching rations:", e); RATIONS = []; }
}

async function fetchSheds() {
  try { SHEDS = await (await fetch(SHEDS_URL + "?cacheBust=" + Date.now())).json(); }
  catch (e) { console.error("Error fetching sheds:", e); SHEDS = []; }
}

/*
 Improved detection for yesterday's percentage values:
 - Accepts numbers, strings like "105%", "1.05", "0.87", "105"
 - Heuristics:
   * If value is a string containing "%", strip and use as percent.
   * If numeric and 0 < val < 1  => treat as fraction (0.87 -> 87).
   * If numeric and val === 1      => treat as 100.
   * If numeric and 1 < val < 100 and val has fractional part (e.g. 1.05) => treat as decimal percent (1.05 -> 105).
   * If numeric and val >= 100     => keep as-is (already percent integer).
   * Otherwise keep as-is (e.g., 50 stays 50).
*/
async function fetchYesterdays() {
  try {
    const data = await (await fetch(YESTERDAY_URL + "?cacheBust=" + Date.now())).json();
    const yesterdays = {};
    SHEDS.forEach(s => {
      const row = data.find(r => r[0] === s.Shed);
      let display = "0";

      if (!row || row[1] === "No Data" || row[1] == null || row[1] === "") {
        display = "0";
      } else {
        const raw = row[1];
        let val = 0;
        let rawIsString = false;
        let rawHasPercent = false;

        if (typeof raw === 'string') {
          rawIsString = true;
          rawHasPercent = raw.indexOf('%') !== -1;
          const cleaned = raw.replace(/,/g, '').replace('%', '').trim();
          val = parseFloat(cleaned);
          if (isNaN(val)) val = 0;
        } else if (typeof raw === 'number') {
          val = raw;
        } else {
          val = 0;
        }

        // Decide how to interpret val
        if (val === 0) {
          display = "0";
        } else if (rawIsString && rawHasPercent) {
          // "105%" -> 105
          display = Math.round(val).toString();
        } else {
          // numeric or string without % sign
          if (val > 0 && val < 1) {
            // 0.87 -> 87
            val = val * 100;
          } else if (val >= 1 && val < 100) {
            // This range is ambiguous:
            // - If it's exactly 1 -> treat as 100
            // - If it has a fractional part (e.g. 1.05) -> treat as decimal percent -> 105
            // - Otherwise assume it's already a percentage (e.g. 50 -> 50)
            if (val === 1 || (val < 10 && (val % 1 !== 0))) {
              val = val * 100;
            }
          }
          display = Math.round(val).toString();
        }

        // helpful debug in console if you want to inspect raw -> display mapping
        // console.log(`YESTERDAY: shed=${s.Shed} raw=${JSON.stringify(raw)} -> display=${display}`);
      }

      yesterdays[s.Shed] = display;
    });
    return yesterdays;
  } catch (e) {
    console.error("Error fetching yesterday's data:", e);
    return {};
  }
}

function computeShedTotal(shed, percent) {
  let total = 0;
  for (let r of RATIONS) {
    if (/total/i.test(r.Ingredient)) continue;
    const qty = r[shed.Ration];
    if (qty != null) total += qty * percent * shed.Headcount;
  }
  return total;
}

async function initInputs() {
  showLoading(true);
  await fetchRations();
  await fetchSheds();
  const yesterdays = await fetchYesterdays();
  TOTAL_HEADCOUNT = SHEDS.reduce((sum, s) => sum + (s.Headcount || 0), 0);
  document.getElementById("totalHeadcount").textContent = `Total Headcount: ${TOTAL_HEADCOUNT}`;
  const container = document.getElementById("inputs");
  container.innerHTML = "<table><thead><tr><th>Shed</th><th>% of Target</th></tr></thead><tbody>" +
    SHEDS.map((s,i)=>{
      const placeholder = yesterdays[s.Shed] || 0;
      return `<tr><td>${s.Shed}</td><td><input type="number" id="shed${i}" placeholder="${placeholder}"></td></tr>`;
    }).join('') +
    "</tbody></table>";
  showLoading(false);
}

function generatePlan() {
  const percentages = SHEDS.map((s,i)=>{
    const el = document.getElementById("shed"+i);
    let val = (el && el.value) ? el.value.trim() : "";
    if (!val) val = el ? el.placeholder : "0";
    return parseFloat(val)/100 || 0;
  });

  const rationGroups = {};
  SHEDS.forEach((shed,i)=>{
    const percent = percentages[i];
    const total = computeShedTotal(shed, percent);
    if (!rationGroups[shed.Ration]) rationGroups[shed.Ration] = [];
    rationGroups[shed.Ration].push({shed, percent, total, percentStr: (percent*100).toFixed(0)+"%"});
  });

  PLAN = [];
  Object.entries(rationGroups).forEach(([rationType,sheds])=>{
    sheds.sort((a,b)=>b.total-a.total);
    let batches=[], current={sheds:[], total:0};
    sheds.forEach(s=>{
      if(s.total + current.total <= MAX_BATCH || current.sheds.length===0){
        current.sheds.push(s); current.total += s.total;
      } else { batches.push(current); current={sheds:[s], total:s.total}; }
    });
    if(current.sheds.length>0) batches.push(current);
    batches.forEach((batch,idx)=>PLAN.push({rationType, idx:idx+1, sheds:batch.sheds, total:batch.total}));
  });

  const output = document.getElementById("planOutput");
  output.style.display = "block";
  output.innerHTML = `<button id="printBtn" onclick="printPlan()">Print</button>
                      <button id="pdfBtn" onclick="downloadPDF()">Download PDF</button>
                      <h2>Date: ${new Date().toISOString().slice(0,10)}</h2>`;
  PLAN.forEach(batch=>{
    let html = `<h3>Mix ${batch.idx} - ${batch.rationType} - Total: ${Math.round(batch.total)} kg</h3>`;
    html += `<table><tr><th>Shed</th><th>%</th><th>Headcount</th><th>Total (kg)</th></tr>`;
    batch.sheds.forEach(s=>{
      html += `<tr><td>${s.shed.Shed}</td><td>${s.percentStr}</td><td>${Math.round(s.shed.Headcount)}</td><td>${Math.round(s.total)}</td></tr>`;
    });
    html += `</table>`;
    const ingredientTotals = {};
    RATIONS.forEach(r=>{ if(!/total/i.test(r.Ingredient)) ingredientTotals[r.Ingredient]=0; });
    batch.sheds.forEach(s=>{
      RATIONS.forEach(r=>{
        if (/total/i.test(r.Ingredient)) return;
        const q = r[s.shed.Ration];
        if (q != null) ingredientTotals[r.Ingredient] += q * s.percent * s.shed.Headcount;
      });
    });
    html += `<table><tr><th>Ingredient</th><th>Quantity (kg)</th></tr>`;
    Object.entries(ingredientTotals).forEach(([ing,qty])=>{
      html += `<tr><td>${ing}</td><td>${Math.round(qty)}</td></tr>`;
    });
    html += `</table>`;
    output.innerHTML += html;
  });

  document.getElementById("planOutput").scrollIntoView({ behavior: "smooth" });
}

function printPlan() { window.print(); }

function downloadPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  const dateStr = new Date().toISOString().slice(0,10);

  const img = new Image();
  img.crossOrigin = "Anonymous";
  img.src = "https://raw.githubusercontent.com/adamcwhall-coder/feeding-plan/main/0EC2FEE7-BD1C-4332-AAB4-AAD5FF7BD04A.png";

  img.onload = function(){
    const pdfWidth = 140;
    const pdfHeight = (img.height / img.width) * pdfWidth;
    doc.addImage(img, "JPEG", 35, 20, pdfWidth, pdfHeight);

    let y = 20 + pdfHeight + 15;
    doc.setFontSize(22);
    doc.text("New Blainslie Feeding Plan", 105, y, { align: "center" });
    y += 15;
    doc.setFontSize(14);
    doc.text(`Date: ${dateStr}`, 105, y, { align: "center" });
    y += 15;
    doc.text(`Total Headcount: ${TOTAL_HEADCOUNT}`, 105, y, { align: "center" });

    PLAN.forEach((batch, idx)=>{
      doc.addPage();
      doc.setFontSize(14);
      doc.text(`Mix ${batch.idx} - ${batch.rationType} - Total: ${Math.round(batch.total)} kg`, 14, 20);

      doc.autoTable({
        startY: 30,
        head: [["Shed","%","Headcount","Total (kg)"]],
        body: batch.sheds.map(s=>[s.shed.Shed,s.percentStr,Math.round(s.shed.Headcount),Math.round(s.total)]),
        theme: "striped",
        headStyles: { fillColor:[42,110,187], halign:"center" },
        styles: { halign:"center" }
      });

      const ingredientTotals = {};
      RATIONS.forEach(r=>{ if(!/total/i.test(r.Ingredient)) ingredientTotals[r.Ingredient]=0; });
      batch.sheds.forEach(s=>{
        RATIONS.forEach(r=>{
          if(/total/i.test(r.Ingredient)) return;
          const q=r[s.shed.Ration];
          if(q!=null) ingredientTotals[r.Ingredient]+=q*s.percent*s.shed.Headcount;
        });
      });

      doc.autoTable({
        startY: doc.lastAutoTable.finalY + 10,
        head: [["Ingredient","Quantity (kg)"]],
        body: Object.entries(ingredientTotals).map(([ing,qty])=>[ing,Math.round(qty)]),
        theme: "grid",
        headStyles: { fillColor:[42,110,187], halign:"center" },
        styles: { halign:"center" }
      });
    });

    doc.save(`feeding_plan_${dateStr}.pdf`);
  };
}

initInputs();
</script>
</body>
</html>